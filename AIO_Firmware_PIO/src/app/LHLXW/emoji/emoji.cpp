#include "emoji.h"
#include "stdlib.h" // print
#include "emoji_GUI.h"
#include "../LHLXW.h"

/*
Function: QQ Super Emoji
Instructions: Left/Right to select different emojis, tilt down to play the current emoji, tilt back to exit current play/exit current function
Others:
QQ Super Emoji is a type of lottie animation, directly parsing lottie animation on a microcontroller is difficult (but possible)
For how to get QQ Super Emoji, see:
[Transparent Small TV & QQ Super Emoji] https://www.bilibili.com/video/BV1dC4y1q7R7/?share_source=copy_web&vd_source=68337adbea96c8cef50403a4b2809df6

The emoji function relies on the video playback library in the media_player APP

SD card storage instructions (emoji related functions):
./LH&LXW/emoji/videos/videox.mjpeg stores the video to be played (size 240x240) (x is 0~99)
./LH&LXW/emoji/images/imagex.bin stores the cover of the video to be played (size 60x60) (x is 0~99)
./LH&LXW/emoji/emoji_num.txt stores the number of videos to be played (00~99) For example, 7 videos, write 07

The number of videos in ./LH&LXW/emoji/videos/ must be equal to the number of covers in ./LH&LXW/emoji/images/
It must also be equal to the number of videos entered by the user in ./LH&LXW/emoji/emoji_num.txt

The cover must be generated by the lvgl official img tool, the multifunctional upper computer cannot generate it

So when using this function as a video player, the steps to add a custom video are as follows:
1. Get the video, use the multifunctional upper computer to convert it to 240x240 mjpeg format (parameters are recommended to use the default)
2. Rename this video to videoxx.mjpeg
3. Capture a picture from this video, the aspect ratio should be as close to 1:1 as possible
4. Rename this picture to imagexx.jpg
5. Use the built-in drawing tool of Windows to change its size to 60x60 (do not maintain the original ratio when modifying)
6. Use the lvgl official img tool to convert it to imagexx.bin
7. Put imagexx.bin and videoxx.mjpeg in the corresponding folder on the SD card
8. Modify the total number of videos in emoji_num.txt
9. Open the APP, and you can see the corresponding video in the emoji function
(If you want to achieve a black background for the video, you can use editing software to process it; you can also use openCV to process it, but it only supports pure color backgrounds;
openCV replaces all QQ Super Emoji background colors at once:
[QQ Super Emoji Background Color Replacement] https://www.bilibili.com/video/BV1cb4y1G7Sy/?share_source=copy_web&vd_source=68337adbea96c8cef50403a4b2809df6)
*/

/* System Variables */
extern bool isCheckAction;
extern ImuAction *act_info;

#define emoji_play_time 33333 // Automatically play the next emoji after (emoji_play_time)ms, can also be switched manually

EMOJI_RUN *emj_run = NULL;

static void emoji_init(void){
    emj_run = (EMOJI_RUN*)calloc(1,sizeof(EMOJI_RUN)); // Using malloc here will cause video playback to fail!!!
    if(emj_run == NULL){
        Serial.println("1:lack of memory");
        while(1);
    }  
    emj_run->emoji_var = 1; // Reset the currently selected emoji number
    emj_run->mpu6050key_var = 0; // The state value of mpu6050 after entering the APP, left tilt is 2, right tilt is 1, the rest is 0
    emj_run->emoji_mode = true; // app running mode, true for selecting emoji, false for playing emoji
    File dataFile = SD.open("/LH&LXW/emoji/emoji_num.txt","r"); // Create a File object to read files from SPIFFS
    emj_run->emoji_Maxnum = (dataFile.read() - '0')*10;
    emj_run->emoji_Maxnum += (dataFile.read() - '0'); // Total number of emojis (SPIFFS is not used, so the number is manually entered, that is, read the SD card configuration file)
    Serial.print(emj_run->emoji_Maxnum);
    dataFile.close(); // Close the file after reading
    EMOJI_GUI_Init();
}

/* Close Playback */
static void close_player(void){
    delete emj_run->emoji_decoder;
    emj_run->emoji_file.close();
}
/* Start Playback */
static void start_player(void){
    char *path = (char*)malloc(38); // Must use char* type, cannot use uint8_t*
    sprintf(path,"/LH&LXW/emoji/videos/video%d.mjpeg",emj_run->emoji_var); // Icon path
    emj_run->emoji_file = tf.open(path);
    emj_run->emoji_decoder = new MjpegPlayDecoder(&emj_run->emoji_file, true);
    free(path);  
}
void emoji_process(lv_obj_t *ym)
{
    unsigned long *timCont = (unsigned long*)malloc(4);
    emoji_init();
    act_info->active = ACTIVE_TYPE::UNKNOWN;
    act_info->isValid = 0;
    while(1){
        /* Refresh lvgl only when selecting emoji */
        if(emj_run->emoji_mode)lv_timer_handler();
        else{
            if(emj_run->emoji_file.available()){
                emj_run->emoji_decoder->video_play_screen(); // Play one frame of data
            }else{
                /* Check if it has exceeded 3333ms */
                if(millis()-(*timCont) > emoji_play_time){
                    next_emoji(); // Update the selected emoji on the emoji selection page
                    emj_run->emoji_var ++;
                    if(emj_run->emoji_var > emj_run->emoji_Maxnum)emj_run->emoji_var = 1;
                    *timCont = millis();
                }
                close_player();
                start_player();
                emj_run->emoji_decoder->video_play_screen(); // Play one frame of data immediately
            }
        }
        /* MPU6050 data acquisition */
        if (isCheckAction){
            isCheckAction = false;
            act_info = mpu.getAction();
        }

        /* MPU6050 action response */
        if (RETURN == act_info->active){
            /* Exit app when selecting emoji */
            if(emj_run->emoji_mode){
                EMOJI_GUI_DeInit(ym); // There is an LVGL animation when exiting the APP, so the system exit function can only be called after the animation ends, so the UI exit cannot be placed in LHLXW_exit_callback
                lv_obj_invalidate(lv_scr_act()); // Even if the cache has not changed, let lvgl update the entire screen next time
                /* Delay 999ms to prevent simultaneous exit from the app */
                for(uint16_t i=0;i<898;i++){
                    lv_timer_handler(); // Let LVGL update the screen so that the operator can see the executed action
                    delay(1); //
                }
                // close_player(); // This must be in the closed playback state, otherwise the system will crash
                free(emj_run); // Free memory
                return; // Exit this function
            }
            /* Exit emoji playback when playing emoji */
            else{
                emj_run->emoji_mode = true;
                close_player(); // Close playback
                lv_obj_invalidate(lv_scr_act()); // Even if the cache has not changed, let lvgl update the entire screen next time
                /* Delay 999ms to prevent simultaneous exit from the emoji function */
                for(uint16_t i=0;i<898;i++){
                    lv_timer_handler(); // Let LVGL update the screen so that the operator can see the executed action
                    delay(1); //
                }
            }
        }else if(TURN_RIGHT == act_info->active && emj_run->mpu6050key_var != 1){
            if(emj_run->emoji_mode)
                emj_run->mpu6050key_var = 1;    
            else{
                next_emoji(); // Update the selected emoji on the emoji selection page
                emj_run->emoji_var ++;
                if(emj_run->emoji_var > emj_run->emoji_Maxnum)emj_run->emoji_var = 1;
                *timCont = millis(); // Restart timing
                close_player();
                start_player();
            }
            for(uint16_t i=0;i<388;i++){
                if(emj_run->emoji_mode)lv_timer_handler(); //
                delay(1); //
            }
        }else if(TURN_LEFT == act_info->active && emj_run->mpu6050key_var != 2){
            if(emj_run->emoji_mode)
                emj_run->mpu6050key_var = 2;    
            else{
                prev_emoji(); // Update the selected emoji on the emoji selection page
                emj_run->emoji_var --;
                if(emj_run->emoji_var < 1)emj_run->emoji_var = emj_run->emoji_Maxnum;
                *timCont = millis(); // Restart timing
                close_player();
                start_player();
            }
            for(uint16_t i=0;i<388;i++){
                if(emj_run->emoji_mode)lv_timer_handler(); //
                delay(1); //
            }
        }else if(act_info->active == UP){
            if(emj_run->emoji_mode){
                start_player();
                emj_run->emoji_mode = false;
                *timCont = millis(); // Record the start time of playback
            }
        } 
        act_info->active = ACTIVE_TYPE::UNKNOWN;
        act_info->isValid = 0;
    }
    free(timCont);
}
