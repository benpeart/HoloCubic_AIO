#include "sys/app_controller.h"
#include "lvgl.h"
#include "stdlib.h"
#include "math.h"

/*
Function: Cyber Album
Instructions: Tilt left to stop auto-switching, tilt right to resume auto-switching, tilt back to switch between static and dynamic
SD card storage instructions (cyber related functions):
./LH&LXW/cyber/imgx.cyber       Store the image files to be displayed (x is 0~99)
./LH&LXW/cyber/cyber_num.txt    Store the number of image files to be displayed (00~99) For example, 7 images, write 07

.cyber format image files are generated by a few lines of python code. Input an image you want to display (48x40), and you will get the corresponding .cyber file
Python code (python-v 3.8.16 openCV-v 4.7.0):
import cv2
img_path = './123.jpg'#input image path
out_path = './123.cyber'#output file path
img = cv2.imread(img_path)
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
with open(out_path, 'wb') as f:
    for a in img:
        for b in a:
            f.write(b)
*/

/* System variables */
extern bool isCheckAction;
extern ImuAction *act_info;

#define cyber_play_time 2000//2000ms auto-switch

struct cyber_run {
    bool flg;//true: current screen displays pic1, false: current screen displays pic2
    bool auto_play;//true: auto-switch, false: no auto-switch
    bool dynamic;//true: dynamic, false: static
    bool str;//true: image composed of random "012<+=", false: image composed of '0' only
    uint8_t cyber_num;//total number of images in the tf card
    uint8_t cn;//current image being played
    uint8_t py;//
    uint8_t con;//
    unsigned long timCon;
    uint8_t *testBuf;//single byte buffer for the screen
    uint8_t *pic1;//define two image buffers to achieve switching
    uint8_t *pic2;  
    File file;
};
cyber_run *cy_r=NULL;

/* Release the memory used by this function */
void free_cy_r(void){
    free(cy_r->pic1);
    free(cy_r->pic2);
    free(cy_r->testBuf);
    free(cy_r);
}

/* Fill the screen buffer */
static void testBuf_fill(uint8_t color){
    uint8_t i = 0;
    uint8_t j = 0;
    for (i = 0; i < 240; ++i)
        for (j = 0; j < 240; ++j)
            cy_r->testBuf[i * 240 + j] = color;
}

/* 5x6 size characters, total 6 characters, Modulation method: negative code, column-wise, forward, C51 */
const uint8_t font_scr[6][5]={
	0x38,0x44,0x44,0x38,0x00,
	0x00,0x44,0x7C,0x04,0x00,
	0x10,0x10,0x7C,0x10,0x00,//+
	0x4C,0x54,0x54,0x24,0x00,
	0x00,0x30,0x50,0x48,0x00,/*"<",7*/
	0x50,0x50,0x50,0x50,0x00,
};
/* Draw the specified character (character is font_scr[n]) at the specified position with the specified color */
// void df(uint8_t x,uint8_t y,uint8_t n,uint16_t color){
// 	uint8_t i=0,ii=0;
// 	uint8_t y0=y;
// 	for(;i<5;i++){
// 		for(ii=0;ii<6;ii++){
// 			if(font_scr[n][i] & (0x80>>ii))
// 				cy_r->testBuf[x+240*y] = color;
// 			y++;
// 		}
// 		y=y0;
// 		x++;
// 	}
// }
/* Draw the character (character is font_scr[n]) at the specified position with the color in the image buffer */
void dfpius(uint8_t x,uint8_t y,uint8_t n,const uint8_t *img){
	uint8_t i=0,ii=0;
	uint8_t y0=y;
	for(;i<5;y=y0,x++,x%=240,i++)//If you don't understand, same as below
		for(ii=0;ii<6;y++,y%=240,ii++)//Put the third expression, except i++, in the order from left to right into the for loop, it will be easier to understand
            if(font_scr[n][i] & (0x80>>ii))
                cy_r->testBuf[x+240*y] = map(img[y/6*48+x/5],0,255,0,7)<<2;		
}

/* The execution time of this function can be optimized to be faster, but since there is a delay anyway, there is no need to optimize */
void drawImg(void){
    testBuf_fill(0);
    uint8_t i=0, ii=0;
    for(;i<48;i++){
        for(ii=0;ii<40;ii++){
            if(cy_r->con<240){
                if((ii*6+cy_r->py)%240<cy_r->con)//Switch from top to bottom
                // if(i*5<cy_r->con)//Switch from left to right (can achieve switching in four directions: up, down, left, and right, here only top to bottom is implemented)
                    dfpius(i*5,(ii*6+cy_r->py)%240,rand()%(1+cy_r->str*5),cy_r->flg==true?cy_r->pic1:cy_r->pic2);
                else 
                    dfpius(i*5,(ii*6+cy_r->py)%240,rand()%(1+cy_r->str*5),cy_r->flg==true?cy_r->pic2:cy_r->pic1);                    
            }else
                dfpius(i*5,(ii*6+cy_r->py)%240,rand()%(1+cy_r->str*5),cy_r->flg==true?cy_r->pic1:cy_r->pic2);
        }
    }
    tft->pushImage(0, 0, 240, 240, cy_r->testBuf);//Display image
    cy_r->py++;
    cy_r->py%=241;
    if(cy_r->con<240){//The screen is switching images
        cy_r->con++;
        delay(9+rand()%14);
    }else if(cy_r->con!=245){//The screen image switching is complete, start updating the currently not displayed image buffer from the tf card (takes about 22.25ms)
        cy_r->cn++;
        if(cy_r->cn>cy_r->cyber_num)cy_r->cn=1;
        char *path = (char*)malloc(26);//Must use char* type, cannot use uint8_t*
        sprintf(path,"/LH&LXW/cyber/img%d.cyber",cy_r->cn);//Icon path
        cy_r->file = SD.open(path,"r");//Create a File object to read files from SPIFFS
        for(uint16_t i=0;i<1920;i++)
            if(cy_r->flg)cy_r->pic2[i] = cy_r->file.read();
            else cy_r->pic1[i] = cy_r->file.read();
        cy_r->file.close();//Close the file after reading
        free(path);
        cy_r->con=245;
        cy_r->timCon = millis();//Timing cyber_play_time milliseconds
    }else{ 
        delay(9+rand()%14);
        if(millis()-cy_r->timCon > cyber_play_time && cy_r->auto_play){//Timing cyber_play_time milliseconds
            cy_r->flg = !cy_r->flg;
            cy_r->con = 0;
        }
    }
}

void cyber_pros(lv_obj_t *ym){

    cy_r = (cyber_run*)calloc(1,sizeof(cyber_run));
    if(cy_r == NULL){
        Serial.println("0:lack of memory");
        while(1);
    }  
    cy_r->testBuf = (uint8_t *)malloc(240 * 240); //Dynamically allocate a space the size of the screen resolution
    if(cy_r->testBuf == NULL){
        Serial.println("1:lack of memory");
        while(1);
    }  
    cy_r->pic1 = (uint8_t *)malloc(40*48); //Dynamically allocate a space the size of the image
    if(cy_r->pic1 == NULL){
        Serial.println("-1:lack of memory");
        while(1);
    }  
    cy_r->pic2 = (uint8_t *)malloc(40*48); //Dynamically allocate a space the size of the image
    if(cy_r->pic2 == NULL){
        Serial.println("1-:lack of memory");
        while(1);
    }
    cy_r->file = SD.open("/LH&LXW/cyber/cyber_num.txt","r");//Create a File object to read files from SPIFFS
    if(!cy_r->file){free_cy_r();return;}
    cy_r->cyber_num = (cy_r->file.read() - '0')*10;//Read the number of images
    cy_r->cyber_num += (cy_r->file.read() - '0');
    Serial.print("cyber_num:");Serial.println(cy_r->cyber_num);
    cy_r->file.close();//Close the file after reading      

    /* Check if the files exist, if they all exist, no need to check when opening later */
    for(uint8_t i=1;i<=cy_r->cyber_num;i++){
        char *test_ = (char*)malloc(26);//Must use char* type, cannot use uint8_t*
        sprintf(test_,"/LH&LXW/cyber/img%d.cyber",i);//Icon path
        cy_r->file = SD.open(test_,"r");//Create a File object to read files from SPIFFS
        if(!cy_r->file){free_cy_r();return;}
        cy_r->file.close(); 
        free(test_);
    }

    cy_r->cn=1;//Start from the first image
    cy_r->con=0;
    cy_r->py=0;
    cy_r->auto_play = true;
    cy_r->flg = true;
    cy_r->dynamic = true;
    cy_r->str = true;

    /* Read data from the memory card to image buffer 1 */
    cy_r->file = SD.open("/LH&LXW/cyber/img1.cyber","r");
    for(uint16_t i=0;i<1920;i++)
        cy_r->pic1[i] = cy_r->file.read();
    cy_r->file.close();//Close the file after reading
    /* Randomly fill the image buffer 2 with color */
    for(uint16_t i=0;i<1920;i++)
        cy_r->pic2[i] = rand()%99;

    /* Achieve smooth app switching */
    lv_obj_t *obj = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(obj,lv_color_hex(0),LV_STATE_DEFAULT);
    lv_scr_load_anim(obj, LV_SCR_LOAD_ANIM_OUT_BOTTOM, 673, 0, false);
    for(uint16_t i=0;i<873;i++){
        lv_timer_handler();//Let LVGL update the screen so the operator can see the executed actions
        delay(1);//
    }
    
//     testBuf_fill(0);
//     lv_scr_load_anim(ym, LV_SCR_LOAD_ANIM_OUT_TOP, 599, 0, false);//Before calling the system exit function, be sure to wait for the animation to end, otherwise it will cause the system to restart
//     lv_obj_invalidate(lv_scr_act());//Even if the cache has not changed, let lvgl update the entire screen next time
//     /* Delay 999ms to prevent simultaneous exit from the app */
//     for(uint16_t i=0;i<598+500;i++){
//         lv_timer_handler();//Let LVGL update the screen so the operator can see the executed actions
//         delay(1);//
//     }
//     lv_obj_clean(obj);
//     lv_obj_del(obj);
//     free(cy_r->testBuf);//Release 57600 bytes of memory
//     free(cy_r->pic2);//Release 1920 bytes of memory
//     free(cy_r->pic1);//Release 1920 bytes of memory
//     free(cy_r);
// return;

    while(1){
        if(cy_r->dynamic)
            drawImg();  
        act_info->active = ACTIVE_TYPE::UNKNOWN;
        act_info->isValid = 0;
        /* MPU6050 data acquisition */
        if (isCheckAction){
            isCheckAction = false;
            act_info = mpu.getAction();
        }
        /* MPU6050 action response */
        if (RETURN == act_info->active){
            break;
        }else if(TURN_RIGHT == act_info->active){
            cy_r->str=!cy_r->str;
            delay(700);
        }else if(TURN_LEFT == act_info->active){
            cy_r->auto_play = !cy_r->auto_play;
            delay(700);
        }else if(act_info->active == UP){
            cy_r->dynamic=!cy_r->dynamic;
            if(cy_r->dynamic)
                for(uint8_t i=0;i<29;i++)
                    drawImg();  
            else delay(700);                
        } 
    }

    lv_scr_load_anim(ym, LV_SCR_LOAD_ANIM_OUT_TOP, 599, 0, false);//Before calling the system exit function, be sure to wait for the animation to end, otherwise it will cause the system to restart
    lv_obj_invalidate(lv_scr_act());//Even if the cache has not changed, let lvgl update the entire screen next time
    /* Delay 999ms to prevent simultaneous exit from the app */
    for(uint16_t i=0;i<598+500;i++){
        lv_timer_handler();//Let LVGL update the screen so the operator can see the executed actions
        delay(1);//
    }
    lv_obj_clean(obj);
    lv_obj_del(obj);

    
    free(cy_r->testBuf);//Release 57600 bytes of memory
    free(cy_r->pic2);//Release 1920 bytes of memory
    free(cy_r->pic1);//Release 1920 bytes of memory
    free(cy_r);

}
